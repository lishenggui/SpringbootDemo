特点：
全局唯一性：不能出现有重复的ID标识，这是基本要求。
递增性：确保生成ID对于用户或业务是递增的。
高可用性：确保任何时候都能生成正确的ID。
高性能性：在高并发的环境下依然表现良好。

方案：
1.UUID
UUID(Universally Unique Identifier)的标准型式包含32个16进制数字，以连字号分为五段，形式为8-4-4-4-12的36个字符，示例：550e8400-e29b-41d4-a716-446655440000
UUID优点：
a.性能非常高：本地生成，没有网络消耗。
UUID缺点：
a.不易于存储：UUID太长，16字节128位，通常以36长度的字符串表示，很多场景不适用;
b.信息不安全：基于MAC地址生成UUID的算法可能会造成MAC地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置;
c.ID作为主键时在特定的环境会存在一些问题，比如做DB主键的场景下，UUID就非常不适用。

2.数据库id
以MySQL举例，利用给字段设置auto_increment_increment和auto_increment_offset来保证ID自增，每次业务使用下列SQL读写MySQL得到ID号。
数据库生成ID优点：
非常简单，利用现有数据库系统的功能实现，成本小，有DBA专业维护。
ID号单调自增，可以实现一些对ID有特殊要求的业务。
数据库生成ID缺点：
强依赖DB，当DB异常时整个系统不可用，属于致命问题。配置主从复制可以尽可能的增加可用性，但是数据一致性在特殊情况下难以保证。主从切换时的不一致可能会导致重复发号。
ID发号性能瓶颈限制在单台MySQL的读写性能。

3.Redis生成ID
当使用数据库来生成ID性能不够要求的时候，我们可以尝试使用Redis来生成ID。
这主要依赖于Redis是单线程的，所以也可以用生成全局唯一的ID。可以用Redis的原子操作 INCR和INCRBY来实现。
比较适合使用Redis来生成每天从0开始的流水号。比如订单号=日期+当日自增长号。可以每天在Redis中生成一个Key，使用INCR进行累加。
Redis生成ID优点：
1）不依赖于数据库，灵活方便，且性能优于数据库。
2）数字ID天然排序，对分页或者需要排序的结果很有帮助。
Redis生成ID缺点：
1）如果系统中没有Redis，还需要引入新的组件，增加系统复杂度。
2）需要编码和配置的工作量比较大。

4.snowflake雪花算法生成ID
SnowFlake 算法结构如下：大致分为了无效位、时间位、机器位和序列号位。
1）第一位 占用1bit，其值始终是0，没有实际作用（因为二进制中最高位是符号位，1表示负数，0表示正数。生成的id一般都是用整数，所以最高位固定为0）。
2）时间戳 占用41bit，精确到毫秒，总共可以容纳约69年的时间。
3）工作机器id 占用10bit，其中高位5bit是数据中心ID，低位5bit是工作节点ID，做多可以容纳1024个节点。
4）序列号 占用12bit，每个节点每毫秒0开始不断累加，最多可以累加到4095，一共可以产生4096个ID

SnowFlake算法优点：是全局唯一、自增、有序、纯数字组成查询效率高且不依赖于数据库。适合在分布式的场景中应用，可根据需求调整具体实现细节。
SnowFlake算法缺点：依赖于系统时间，雪花算法在单机系统上ID是递增的，但是在分布式系统多节点的情况下，所有节点的时钟改变或者其他情况，就有可能会出现不是全局递增的情况。